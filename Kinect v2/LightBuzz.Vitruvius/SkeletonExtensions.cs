using System;
using Microsoft.Kinect;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Collections.Generic;

namespace LightBuzz.Vitruvius
{
    /// <summary>
    /// Provides some common functionality for manupulating skeletal data.
    /// </summary>
    public static class SkeletonExtensions
    {
        #region Public methods

        /// <summary>
        /// Returns the bodies found in the current frame.
        /// </summary>
        /// <param name="frame">The BodyFrame generated by the Kinect sensor.</param>
        /// <returns>An array of bodies or an empty array if no bodies were found.</returns>
        public static IEnumerable<Body> Bodies(this BodyFrame frame)
        {
            IList<Body> bodies = new Body[frame.BodyFrameSource.BodyCount];

            frame.GetAndRefreshBodyData(bodies);

            return bodies;
        }

        /// <summary>
        /// Returns the default body, aka the one that is currently in front of the Kinect sensor.
        /// </summary>
        /// <param name="bodies">A list of bodies to look at.</param>
        /// <returns>The first tracked body.</returns>
        public static Body Default(this IEnumerable<Body> bodies)
        {
            return bodies.Where(b => b.IsTracked).FirstOrDefault();
        }

        /// <summary>
        /// Retruns the height of the specified body.
        /// </summary>
        /// <param name="body">The specified user body.</param>
        /// <returns>The height of the body in meters.</returns>
        public static double Height(this Body body)
        {
            const double HEAD_DIVERGENCE = 0.1;

            var head = body.Joints[JointType.Head];
            var neck = body.Joints[JointType.Neck];
            var shoulders = body.Joints[JointType.SpineShoulder];
            var spine = body.Joints[JointType.SpineMid];
            var waist = body.Joints[JointType.SpineBase];
            var hipLeft = body.Joints[JointType.HipLeft];
            var hipRight = body.Joints[JointType.HipRight];
            var kneeLeft = body.Joints[JointType.KneeLeft];
            var kneeRight = body.Joints[JointType.KneeRight];
            var ankleLeft = body.Joints[JointType.AnkleLeft];
            var ankleRight = body.Joints[JointType.AnkleRight];
            var footLeft = body.Joints[JointType.FootLeft];
            var footRight = body.Joints[JointType.FootRight];

            // Find which leg is tracked more accurately.
            int legLeftTrackedJoints = NumberOfTrackedJoints(hipLeft, kneeLeft, ankleLeft, footLeft);
            int legRightTrackedJoints = NumberOfTrackedJoints(hipRight, kneeRight, ankleRight, footRight);

            double legLength = legLeftTrackedJoints > legRightTrackedJoints ? Distance(hipLeft, kneeLeft, ankleLeft, footLeft) : Distance(hipRight, kneeRight, ankleRight, footRight);            

            return Distance(head, neck, shoulders, spine, waist) + legLength + HEAD_DIVERGENCE;
        }

        /// <summary>
        /// Returns the upper height of the specified body (head to waist).
        /// </summary>
        /// <param name="body">The specified user body.</param>
        /// <returns>The upper height of the body in meters.</returns>
        public static double UpperHeight(this Body body)
        {
            var head = body.Joints[JointType.Head];
            var neck = body.Joints[JointType.Neck];
            var shoulders = body.Joints[JointType.SpineShoulder];
            var spine = body.Joints[JointType.SpineMid];
            var waist = body.Joints[JointType.SpineBase];

            return Distance(head, neck, shoulders, spine, waist);
        }

        /// <summary>
        /// Returns the length of the segment defined by the specified joints.
        /// </summary>
        /// <param name="p1">The first joint (start of the segment).</param>
        /// <param name="p2">The second joint (end of the segment).</param>
        /// <returns>The length of the segment in meters.</returns>
        public static double Distance(Joint p1, Joint p2)
        {
            return Math.Sqrt(
                Math.Pow(p1.Position.X - p2.Position.X, 2) +
                Math.Pow(p1.Position.Y - p2.Position.Y, 2) +
                Math.Pow(p1.Position.Z - p2.Position.Z, 2));
        }

        /// <summary>
        /// Returns the length of the segments defined by the specified joints.
        /// </summary>
        /// <param name="joints">A collection of two or more joints.</param>
        /// <returns>The length of all the segments in meters.</returns>
        public static double Distance(params Joint[] joints)
        {
            double length = 0;

            for (int index = 0; index < joints.Length - 1; index++)
            {
                length += Distance(joints[index], joints[index + 1]);
            }

            return length;
        }

        /// <summary>
        /// Returns the distance of the specified joints.
        /// </summary>
        /// <param name="p1">The first joint (start of the segment).</param>
        /// <param name="p2">The second joint (end of the segment).</param>
        /// <returns>The length of the segment in meters.</returns>
        public static double DistanceFrom(this Joint p1, Joint p2)
        {
            return Distance(p1, p2);
        }

        /// <summary>
        /// Given a collection of joints, calculates the number of the joints that are tracked accurately.
        /// </summary>
        /// <param name="joints">A collection of joints.</param>
        /// <returns>The number of the accurately tracked joints.</returns>
        public static int NumberOfTrackedJoints(params Joint[] joints)
        {
            int trackedJoints = 0;

            foreach (var joint in joints)
            {
                if (joint.TrackingState == TrackingState.Tracked)
                {
                    trackedJoints++;
                }
            }

            return trackedJoints;
        }

        /// <summary>
        /// Scales the specified joint according to the specified dimensions.
        /// </summary>
        /// <param name="joint">The joint to scale.</param>
        /// <param name="width">Width.</param>
        /// <param name="height">Height.</param>
        /// <param name="skeletonMaxX">Maximum X.</param>
        /// <param name="skeletonMaxY">Maximum Y.</param>
        /// <returns>The scaled version of the joint.</returns>
        public static Joint ScaleTo(this Joint joint, double width, double height, float skeletonMaxX, float skeletonMaxY)
        {
            joint.Position = new CameraSpacePoint
            {
                X = Scale(width, skeletonMaxX, joint.Position.X),
                Y = Scale(height, skeletonMaxY, -joint.Position.Y),
                Z = joint.Position.Z
            };

            return joint;
        }

        /// <summary>
        /// Scales the specified joint according to the specified dimensions.
        /// </summary>
        /// <param name="joint">The joint to scale.</param>
        /// <param name="width">Width.</param>
        /// <param name="height">Height.</param>
        /// <returns>The scaled version of the joint.</returns>
        public static Joint ScaleTo(this Joint joint, double width, double height)
        {
            return ScaleTo(joint, width, height, 1.0f, 1.0f);
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Returns the scaled value of the specified position.
        /// </summary>
        /// <param name="maxPixel">Width or height.</param>
        /// <param name="maxSkeleton">Border (X or Y).</param>
        /// <param name="position">Original position (X or Y).</param>
        /// <returns>The scaled value of the specified position.</returns>
        private static float Scale(double maxPixel, double maxSkeleton, float position)
        {
            float value = (float)((((maxPixel / maxSkeleton) / 2) * position) + (maxPixel / 2));
            
            if (value > maxPixel)
            {
                return (float)maxPixel;
            }

            if (value < 0)
            {
                return 0;
            }

            return value;
        }

        #endregion
    }
}
